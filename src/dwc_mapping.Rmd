---
title: "Darwin Core mapping"
subtitle: "For: Ad hoc checklist of alien species in Belgium"
author:
- Lien Reyserhove
- Peter Desmet
- Quentin Groom
- Tim Adriaens
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---

This document describes how we map the checklist data to Darwin Core. The source file for this document can be found [here](https://docs.google.com/spreadsheets/d/1LeXXbry2ArK2rngsmFjz_xErwE1KwQ8ujtvHNmTVA6E/edit#gid=0).

# Setup

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Set locale (so we use UTF-8 character encoding):

```{r}
# This works on Mac OS X, might not work on other OS
Sys.setlocale("LC_CTYPE", "en_US.UTF-8")
```

Load libraries:

```{r}
library(tidyverse)       # To transform data
library(magrittr)        # For %<>% pipes
library(googlesheets)    # To import and read Google spreadsheets 
library(janitor)         # To clean input data
library(stringr)         # To perform string operations
library(digest)          # To generate hashes
library(rgbif)           # 
```

Set file paths (all paths should be relative to this script):
 
```{r}
# Raw files:
raw_data_file = "../data/raw/ad_hoc_checklist_dump.csv"

# Processed files:
dwc_taxon_file = "../data/processed/taxon.csv"

```

# # Read and pre-process raw data

The original spreadsheet can be found [here](https://docs.google.com/spreadsheets/d/1LeXXbry2ArK2rngsmFjz_xErwE1KwQ8ujtvHNmTVA6E/edit#gid=0). We need to retrieve this spreadsheet and select the specific worksheet first:

Retrieve the spreadsheet:

```{r}
retrieve_spreadsheet <- gs_title("ad hoc checklist")
```

select the data in the worksheet `checklist`:

```{r}
raw_data <- retrieve_spreadsheet %>% gs_read("checklist")
```

We want to add a copy of the raw ad hoc checklist to the Github repository:

```{r}
write.csv(raw_data, file = raw_data_file, na = "", row.names = FALSE, fileEncoding = "UTF-8")
```

Inspect `raw_data`: 

```{r}
raw_data %>% head()
```

Clean the data somewhat: remove empty rows if present:

```{r}
raw_data %<>%
  remove_empty("rows") %>%    # Remove empty rows
  clean_names()               # Have sensible (lowercase) column names
```

## Generate taxonID

To uniquely identify a taxon in the taxon core and reference taxa in the extensions, we need a `taxonID`. Since we need it in all generated files, we generate it here in the raw data frame. It is a combination of `dataset-shortname:taxon:` and a hash based on the scientific name. As long as the scientific name doesn't change, the ID will be stable.  Some of the names require some minor cleaning first though:

```{r}
raw_data %<>% mutate(scientificname_clean = str_replace_all(scientific_name, "( sp\\.)|( spec\\.)| sp A", ""))
```

Show cleaned values:

```{r}
raw_data %>% 
  select(scientific_name, scientificname_clean) %>% 
  filter(str_detect(scientific_name, "( sp\\.)|( spec\\.)| sp A") == TRUE)
```


```{r}
# Vectorize the digest function (The digest() function isn't vectorized. So if you pass in a vector, you get one value for the whole vector rather than a digest for each element of the vector):
vdigest <- Vectorize(digest)

# Generate taxonID:
raw_data %<>% mutate(taxon_id = paste("ad-hoc-checklist", "taxon", vdigest(scientificname_clean, algo="md5"), sep = ":"))
```

## Further pre-processing:

Add prefix `raw_` to all column names to avoid name clashes with Darwin Core terms:

```{r}
colnames(raw_data) <- paste0("raw_", colnames(raw_data))
```
 
Preview data:

```{r}
raw_data %>% head()
```

# Create taxon core

```{r start_taxon}
taxon <- raw_data
```

## Term mapping

Map the data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml).
 
### language

```{r}
taxon %<>% mutate(language = "en")
```

### license

```{r}
taxon %<>% mutate(license = "http://creativecommons.org/publicdomain/zero/1.0/")
```

### rightsHolder

```{r}
taxon %<>% mutate(rightsHolder = "INBO") 
```

### accessRights

```{r}
taxon %<>% mutate(accessRights = "https://www.inbo.be/en/norms-data-use") 
```

### references

### datasetID

```{r}
taxon %<>% mutate(datasetID = "") 
```

### datasetName

```{r}

```

### taxonID

```{r}
taxon %<>% mutate(taxonID = raw_taxon_id)
```

### scientificName

Deal with duplicates:

Select all rows in the dataframe that contain duplicates:

```{r}
duplicates <- taxon %>%  
  slice(which(duplicated(taxon $ raw_scientific_name) == "TRUE")) %>% 
  select(raw_scientific_name)
```

```{r, eval=FALSE}
duplicates
```

Give all information about these duplicated taxa:

```{r}
taxon %>% 
  filter(raw_scientific_name %in% duplicates $ raw_scientific_name) %>% 
  arrange(raw_scientific_name)
```

Select unique scientific names (remove duplicated records):

```{r}
taxon %<>% filter(duplicated(taxon$ raw_scientific_name)==FALSE)
```

### kingdom

```{r}
taxon %<>% mutate(kingdom = raw_kingdom) 
```

### phylum

```{r}
taxon %<>% mutate(phylum = raw_phylum) 
```

### order

```{r}
taxon %<>% mutate(order = raw_order) 
```

### family

```{r}
taxon %<>% mutate(family = raw_family)
```

### genus

```{r}
taxon %<>% mutate(genus = raw_genus)
```

### taxonRank

```{r}
taxon %<>% mutate(taxonRank = raw_taxon_rank)
```

### nomenclaturalCode

```{r}
taxon %>% mutate(nomenclaturalCode = raw_nomenclatural_code)
```

## Post-processing

Remove the original columns:

```{r}
taxon %<>% select(-starts_with("raw_"))
```

Preview data:

```{r}
taxon %>% head()
```

Save to CSV:

```{r}
write.csv(taxon, file = dwc_taxon_file, na = "", row.names = FALSE, fileEncoding = "UTF-8")
```

# Create distribution extension

```{r start_distribution}
distribution <- raw_data
```

## Term mapping 

Map the data to [Species Distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml).

### taxonID

```{r}
distribution %<>% mutate(taxonID = raw_taxon_id) 
```

### locationID

```{r}
distribution %<>% mutate(locationID = case_when(
  raw_location == "Belgium" ~ "ISO_3166-2:BE",
  raw_location == "Flanders" ~ "ISO_3166-2:BE-VLG",
  raw_location == "Wallonia" ~ "ISO_3166-2:BE-WAL",
  raw_location == "Brussels" ~ "ISO_3166-2:BE-BRU"))
```

### locality

```{r}
distribution %<>% mutate(locality = raw_location) 
```

### countryCode

```{r}
distribution %<>% mutate(countryCode = "BE")
```

### occurrenceStatus

```{r}
distribution %<>% mutate(occurrenceStatus = raw_occurrence_status)
```

### establishmentMeans

```{r}
distribution %<>% mutate(establishmentMeans = "introduced")
```

### eventDate

Information for `eventDate` is contained in `raw_date_first_observation` and `raw_date_last_observation`, which we will express here as an ISO 8601 date `yyyy/yyyy` (`start_date/end_date`).

Inspect `raw_data_first_observation`:

```{r}
unique(distribution $ raw_date_first_observation)
```


Clean `raw_date_first_observation` (remove `>`):

```{r}
distribution %<>% mutate(raw_date_first_observation = str_replace_all(raw_date_first_observation, ">", "")) 
```

`start_date_first_observation` contains empty values. For those we'll consider the publication year of the adhoc checklist as the date when the presence of the species was last verified, except for `Mephitis mephitis`, which was last observed in 2014. For this species, we use `2014` as start date:

```{r}
distribution %<>% mutate(start_date = case_when(
  raw_scientific_name == "Mephitis mephitis (Schreber, 1776)" ~ "2014",
  is.na(raw_date_first_observation) ~ "2018",
  TRUE  ~ raw_date_first_observation
)) 
```

`raw_date_last_observation` should not be before 2018 for those specific records:

```{r}
distribution %>% 
  select(raw_date_first_observation, start_date, raw_date_last_observation) %>% 
  filter (is.na(raw_date_first_observation)) %>% 
  group_by_all() %>% 
  summarize(records = n())
```

Inspect `raw_date_last_observation`:

```{r}
unique(distribution $ raw_date_last_observation)
```

In a similar way as for `raw_date_first_observation`, we use the publication year of the adhoc checklist when no end_year is provided:

```{r}
distribution %<>% mutate(end_date = case_when(
  is.na(raw_date_last_observation) ~ "2018",
  TRUE  ~ raw_date_last_observation
)) 
```

Create `eventDate`:

```{r}
distribution %<>% mutate(eventDate = paste(start_date, end_date, sep = "/")) 
```

### source


